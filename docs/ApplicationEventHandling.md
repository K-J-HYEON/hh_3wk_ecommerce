## 책임 분리를 통한 애플리케이션 설계

### 비즈니스 로직에서 적절한 트랜잭션 범위 고민
### 비즈니스 로직 관심사 분리 -> 이벤트 활용
### 카프카 활용 -> 이벤트 서비스 단위로 확장, 안정적인 이벤트 처리를 위한 방법 알아보기

##

### 문제상황에 따른 트랜잭션 범위
1. 하나의 트랜잭션이 너무 많은 작업 혹은 느린 조회 등을 처리 할 때
2. 트랜잭션 범위 내에서 DB와 무관한 작업을 수행하고 있는 경우

### 애플리케이션 이벤트를 통환 관심사 분리
1. 하나의 로직에서 검증, 재고차감, 주문, 결제 등 많은 관심사를 하나의 작업으로 처리할 수 있음
2. Spring : ApplicationEventPublisher & EventListener & TransactionEventListener


### Event 기반 흐름 제어
1. 구독하는 모델링을 통해서 Event의 강한 결합을 분리
2. Event에 의해 자기의 관심사만 수행하도록 비즈니스 로직간의 의존 느슨하게 함
3. 작업의 논리적 의존이나 관계 파악 필수
4. 이벤트에 의해 파생된 작업이 실패 원래 작업 또 실패 처리 해야 한다면 보상 트랜잭션 및 SAGA 패턴을 사용
5. 이벤트에 의해 각 작업이 영향 주고 있는지 이벤트가 발생하면 안되는 상황에서 이벤ㅌ가 발행되고 있는지 확인해야함

### Issue
#### 이커머스 시나리오에서 데이터 분석을 위해 결제 성공 시에 실시간으로 주문 정보를 데이터 플랫폼에 전송
#### 결제 서비스의 책임 순서 : 결제 요청 검증 -> 포인트 차감 -> 결제 정보 전달 -> 주문 정보 전달
#### 주문 정보 전달이 오래 걸리면 전체 트랜잭션에 영항 미치고 실패하면 결제 이벤트 전체가 실패함
#### 주문 정보 전달은 부가 로직이므로 결제 처리 로직에 영향 끼치지 않게 설계 해야한다.

##

### 카프카 비동기 메세지 통신을 통한 책임 분리
### Transactional Messaging - Eventual Consistency - 결과적 일관성
1. 모든 서비스 간의 데이터 정합성은 맞게 됨
2. 분산 시스템 / 비동기 메세징 환경에서 추구하는 방향
3. 대량의 트래픽을 수용할 수 있도록 작업의 단위(Transaction)를 작게, 비동기로 구성

### 비즈니스 로직 수행 + 후속 이벤트 발행을 원자적으로 수행
### Transactional Messaging의 대표적인 패턴
### Transaction OutBox Pattern
1. 도메인 로직이 성공적으로 수행 -> 이벤트 메세즈를 Outbox Table 라는 별도의 테이블에 저장해 함께 Commit
2. 동일 트랜잭션 내에 이벤트 발행 위한 Outbox 데이터 적재까지 진행하여 이벤트 발행에 대해 보장
3. 이벤트 발생 상태도 Outbox 데이터가 존재해서 배치 프로세스등을 이용해 미발행된 데이터에 대해 Fallback 처리가 용이

### Change Data Capture (CDC)
1. 데이터베이스의 변경 사항을 모니터링하고 다른 시스템으로 해당 변경 사항에 대한 내용 전파하는 프로세스
2. DB에서 데이터가 변경되는 것을 감지 -> 해당 변경 건에 관한 이벤트 발행